#!/usr/bin/env python2

import datetime
import os.path
import pygit2


def split_path(path):
    lst = []
    path = path.rstrip('/')
    (path, tail) = os.path.split(path)
    while tail != '':
        lst.append(tail)
        (path, tail) = os.path.split(path)
    lst.reverse()
    return lst


class Path:
    '''
    Represents a path (file or folder) under source control
    '''
    def __init__(self, path, repo):
        self.path = os.path.relpath(path, repo.workdir)
        self.split = split_path(self.path)
        self.mod_date = None
        self.mod_commit = None
        self.current_hex = None

    def insert_into_file_tree(self, d):
        for p in self.split[:-1]:
            if p in d:
                d = d[p]
                if not isinstance(d, dict):
                    raise ValueError
            else:
                t = dict()
                d[p] = t
                d = t
        d[self.split[-1]] = self

    def __str__(self):
        return "{} last modified on {}".format(
            self.path,
            self.mod_date,
        )

    def __lt__(self, other):
        if self.mod_date is None:
            return True
        elif other.mod_date is None:
            return False
        else:
            return self.mod_date < other.mod_date


def walk_file_tree(file_tree, git_tree, function):
    new_file_tree = dict()
    for path_segment, path in file_tree.iteritems():
        if git_tree is None:
            subtree = None
        elif path_segment in git_tree:
            subtree = git_tree[path_segment]
        else:
            subtree = None

        if isinstance(path, dict):
            new_file_tree[path_segment] = walk_file_tree(path, subtree)
        else:
            if not function(path, subtree):
                new_file_tree[path_segment] = file_tree[path_segment]
    return new_file_tree

if __name__ == '__main__':
    repo = pygit2.Repository(pygit2.discover_repository('.'))
    file_tree = dict()
    listing = os.listdir(os.getcwd())
    #listing = ['git-pivotal']
    paths = [Path(path, repo) for path in listing]

    for p in paths:
        p.insert_into_file_tree(file_tree)

    def set_initial(path, obj):
        if obj is None:
            return True
        else:
            path.current_hex = obj.hex
            return False

    file_tree = walk_file_tree(file_tree, repo.head.tree, set_initial)

    #for p in paths:
    #    print p.path, p.current_hex, p.mod_date

    for revision in repo.walk(repo.head.hex, pygit2.GIT_SORT_TIME):
        def check_for_changes(path, obj):
            if obj is not None and path.current_hex == obj.hex:
                path.mod_date = datetime.datetime.fromtimestamp(revision.commit_time)
                path.mod_commit = revision.hex
                return False
            else:
                return True

        file_tree = walk_file_tree(file_tree, revision.tree, check_for_changes)

    paths.sort(reverse=True)

    for p in paths:
        print p
