#!/usr/bin/env python2

'''
git-recent shows a directory listing inside a git repository, ordered by
commit date.
Copyright (C) 2013  Peter Raboud

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
'''

import argparse
#import colorama
#import datetime
#import itertools
import os.path
import pygit2

import _gitext


# global var containing arguments (including formatting options)


# def print_table(rows, colsep='  '):
#     '''
#     Takes a list of lists of text (rows=[columns]=[[strings]]),
#     and prints out the table so that each string is aligned with the other
#     strings in its column.
#     Each `text` may either be a string, or a two-tuple of a string and color
#     string from colorama. This is done so the color string is not counted
#     in the column width.
#     '''

#     def get_width(text):
#         if isinstance(text, str):
#             return len(text)
#         else:
#             return len(text[0])

#     # width of each column
#     widths = [max(map(get_width, col))
#               for col in itertools.izip_longest(*rows, fillvalue='')]

#     def justify_and_colourize(text, width):
#         if isinstance(text, str):
#             string = text
#             start_colour = ''
#             end_colour = ''
#         else:
#             string = text[0]
#             start_colour = text[1]
#             end_colour = colorama.Fore.RESET
#         return "{start_colour}{text:{width}}{end_colour}".format(
#             text=string,
#             width=width,
#             start_colour=start_colour,
#             end_colour=end_colour,
#         )

#     # print each row, columns seperated by colsep, each column at the
#     # appropriate width
#     for r in rows:
#         cols = [justify_and_colourize(text, width)
#                 for text, width
#                 in itertools.izip_longest(r, widths, fillvalue='')]
#         print colsep.join(cols)


def main():
    description = ('Do a directory listing ordered by last modification date '
                   'by a commit')

    parser = argparse.ArgumentParser(description=description)
    parser.add_argument('files', metavar='files', nargs='*')
    parser.add_argument('-c', '--commit', dest='show_commit',
                        action='store_true')
    parser.add_argument('-u', '--hide-untracked', dest='hide_untracked',
                        action='store_true')
    parser.add_argument('-H', '--show-hidden', dest='show_hidden',
                        action='store_true')
    parser.add_argument('-a', '--author-date', dest='author_date',
                        action='store_true')
    args = parser.parse_args()

    repo_dir = pygit2.discover_repository('.').rstrip('/')
    print repo_dir
    repo_dir = os.path.dirname(repo_dir)
    print repo_dir

    listing = args.files or os.listdir(os.getcwd())

    git_paths = [os.path.relpath(p, repo_dir) for p in listing]

    commits = _gitext.mod_commits(git_paths)

    for p, c in zip(listing, commits):
        print p, c

if __name__ == '__main__':
    main()
